// Generated by IcedCoffeeScript 1.3.3g
(function() {
  var F, F2S, Message, SF, dir, flip_dir, log, sflags_to_flags, show_arg, show_res, type;

  log = require("./log");

  F = {
    NONE: 0,
    METHOD: 0x1,
    REMOTE: 0x2,
    SEQID: 0x4,
    TIMESTAMP: 0x8,
    ERR: 0x10,
    ARG: 0x20,
    RES: 0x40,
    TYPE: 0x80,
    DIR: 0x100,
    PORT: 0x200,
    VERBOSE: 0x400,
    ALL: 0xfffffff
  };

  F.LEVEL_0 = F.NONE;

  F.LEVEL_1 = F.METHOD | F.TYPE | F.DIR | F.TYPE;

  F.LEVEL_2 = F.LEVEL_1 | F.SEQID | F.TIMESTAMP | F.REMOTE | F.PORT;

  F.LEVEL_3 = F.LEVEL_2 | F.ERR;

  F.LEVEL_4 = F.LEVEL_3 | F.RES | F.ARGS;

  SF = {
    m: F.METHOD,
    a: F.REMOTE,
    s: F.SEQID,
    t: F.TIMESTAMP,
    e: F.ERROR,
    p: F.ARG,
    r: F.RES,
    e: F.ERR,
    c: F.TYPE,
    d: F.DIRECTION,
    v: F.VERBOSE,
    P: F.PORT,
    A: F.ALL,
    0: F.LEVEL_0,
    1: F.LEVEL_1,
    2: F.LEVEL_2,
    3: F.LEVEL_3,
    4: F.LEVEL_4
  };

  dir = {
    INCOMING: 1,
    OUTGOING: 2
  };

  flip_dir = function(d) {
    if (d === dir.INCOMING) {
      return dir.OUTGOING;
    } else {
      return dir.INCOMING;
    }
  };

  type = {
    SERVER: 1,
    CLIENT_NOTIFY: 2,
    CLIENT_CALL: 3
  };

  F2S = {};

  F2S[F.DIR] = {};

  F2S[F.DIR][dir.INCOMING] = "in";

  F2S[F.DIR][dir.OUTGOING] = "out";

  F2S[F.TYPE] = {};

  F2S[F.TYPE][type.SERVER] = "server";

  F2S[F.TYPE][type.CLIENT_NOTIFY] = "cli.notify";

  F2S[F.TYPE][type.CLIENT_INVOKE] = "cli.invoke";

  exports.constants = {
    type: type,
    dir: dir,
    flags: F,
    sflags: SF,
    field_to_string: F2S
  };

  exports.sflags_to_flags = sflags_to_flags = function(s) {
    var c, i, res, _i, _ref;
    res = 0;
    for (i = _i = 0, _ref = s.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      c = s.charAt(i);
      res |= SF[c];
    }
    return res;
  };

  show_arg = function(msg, V) {
    return V || ((msg.type === type.SERVER) && (msg.dir === dir.INCOMING)) || ((msg.type !== type.SERVER) && (msg.dir === dir.OUTGOING));
  };

  show_res = function(msg, V) {
    return V || ((msg.type === type.SERVER) && (msg.dir === dir.OUTGOING)) || ((msg.type !== type.SERVER) && (msg.dir === dir.INCOMING));
  };

  exports.make_hook = function(flgs, fn) {
    var V, logger, sflags;
    sflags = flgs;
    if (typeof flgs === 'string') sflags = sflags_to_flags(flgs);
    V = sflags & F.VERBOSE;
    if (!fn) {
      logger = log.new_default_logger();
      fn = function(m) {
        return logger.info(JSON.stringify(m));
      };
    }
    return function(msg) {
      var do_copy, f2s, flag, key, new_msg, uck, val;
      new_msg = {};
      if (sflags & F.TIMESTAMP) {
        new_msg.timestamp = (new Date()).getTime() / 1000.0;
      }
      for (key in msg) {
        val = msg[key];
        uck = key.toUpperCase();
        flag = F[uck];
        do_copy = (sflags & flag) === 0 ? false : key === "res" ? show_res(msg, V) : key === "arg" ? show_arg(msg, V) : true;
        if (do_copy) {
          if ((f2s = F2S[flag]) != null) val = f2s[val];
          new_msg[key] = val;
        }
      }
      return fn(new_msg);
    };
  };

  exports.Message = Message = (function() {
    "A debug message --- a wrapper around a dictionary object, with\na few additional methods.";

    function Message(_msg, hook) {
      this._msg = _msg;
      this.hook = hook != null ? hook : null;
    }

    Message.prototype.response = function(error, result) {
      this._msg.err = error;
      this._msg.res = result;
      return this._msg.dir = flip_dir(this._msg.dir);
    };

    Message.prototype.msg = function() {
      return this._msg;
    };

    Message.prototype.call = function() {
      return this.hook(this.msg());
    };

    Message.prototype.set = function(k, v) {
      return this.msg[k] = v;
    };

    return Message;

  })();

}).call(this);
