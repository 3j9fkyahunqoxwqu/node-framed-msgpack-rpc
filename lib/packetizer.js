// Generated by IcedCoffeeScript 1.3.3f
(function() {
  var Packetizer, Ring, msgpack_frame_len, pack, unpack, _ref;

  _ref = require('msgpack2'), unpack = _ref.unpack, pack = _ref.pack;

  Ring = require('./ring').Ring;

  msgpack_frame_len = function(buf) {
    var bytes;
    bytes = buf[0];
    if (buf < 0x80) {
      return 1;
    } else if (buf === 0xcc) {
      return 2;
    } else if (buf === 0xcd) {
      return 3;
    } else if (buf === 0xce) {
      return 5;
    } else {
      return 0;
    }
  };

  Packetizer = (function() {
    "A packetizer that is used to read and write to an underlying stream\n(like a TcpTransport below).  Should be inherited by such a class.\nThe subclasses should implement:\n\n   @_write(msg,enc) - write this msg to the stream with the\n     given encoding.\n    \n   @_fatal(err) - report an error with the stream\n  \n   @_dispatch(msg) - emit a packetized incoming message\n\nThe subclass should call @packetize_data(m) whenever it has data to stuff\ninto the packetizer's input path, and call @send(m) whenever it wants\nto stuff data into the packterizer's output path.\n ";

    Packetizer.prototype.FRAME = 1;

    Packetizer.prototype.DATA = 2;

    Packetizer.prototype.OK = 0;

    Packetizer.prototype.WAIT = 1;

    Packetizer.prototype.ERR = -1;

    function Packetizer() {
      Packetizer.__super__.constructor.apply(this, arguments);
      this._ring = new Ring();
      this._state = this.FRAME;
      this._next_msg_len = 0;
    }

    Packetizer.prototype.send = function(msg) {
      var b, b1, b2, bufs, enc, rc, _i, _len;
      b2 = pack(msg);
      b1 = pack(b2.length);
      bufs = [b1, b2];
      rc = 0;
      enc = 'binary';
      for (_i = 0, _len = bufs.length; _i < _len; _i++) {
        b = bufs[_i];
        this._raw_write(b.toString(enc), enc);
      }
      return true;
    };

    Packetizer.prototype._get_frame = function() {
      var f0, f_full, frame_len, r, res, typ;
      if (!(this._ring.len() > 0)) return this.WAIT;
      f0 = this._ring.grab(1);
      if (!f0) return this.WAIT;
      frame_len = msgpack_frame_len(f0);
      if (!frame_len) {
        this._fatal("Bad frame header received");
        return this.ERR;
      }
      if ((f_full = this._ring.grab(frame_len)) == null) return this.WAIT;
      r = unpack(f_full);
      res = (function() {
        switch ((typ = typeof r)) {
          case 'number':
            if (r < 0) {
              throw new Error("Negative len " + len + " should not have happened");
            }
            this._ring.consume(frame_len);
            this._next_msg_len = r;
            this._state = this.DATA;
            return this.OK;
          case 'undefined':
            return this.WAIT;
          default:
            this._fatal("bad frame; got type=" + typ + ", which is wrong");
            return this.ERR;
        }
      }).call(this);
      return res;
    };

    Packetizer.prototype._get_msg = function() {
      var b, l, msg, ret;
      l = this._next_msg_len;
      ret = l < this._ring.len() || !((b = this._ring.grab(l)) != null) ? this.WAIT : !((msg = unpack(b)) != null) ? (this._fatal("bad encoding found in data/payload; len=" + l), this.ERR) : (this._ring.consume(l), this._state = this.FRAME, this._dispatch(msg), this.OK);
      return ret;
    };

    Packetizer.prototype.packetize_data = function(m) {
      var go, _results;
      this._ring.buffer(m);
      go = this.OK;
      _results = [];
      while (go === this.OK) {
        _results.push(go = this._state === this.FRAME ? this._get_frame() : this._get_msg());
      }
      return _results;
    };

    return Packetizer;

  })();

}).call(this);
