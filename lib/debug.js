// Generated by IcedCoffeeScript 1.3.3g
(function() {
  var F, F2S, Message, dir, sflags, sflags_to_flags, type;

  F = {
    NONE: 0,
    METHOD: 0x1,
    REMOTE: 0x2,
    SEQID: 0x4,
    TIMESTAMP: 0x8,
    ERROR: 0x10,
    ARG: 0x20,
    RES: 0x40,
    CLASS: 0x80,
    DIR: 0x100,
    VERBOSE: 0x200,
    ALL: 0xfffffff
  };

  F.LEVEL_0 = F.NONE;

  F.LEVEL_1 = F.METHOD | F.CLASS | F.DIR;

  F.LEVEL_2 = F.LEVEL_1 | F.SEQID | F.TIMESTAMP | F.REMOTE;

  F.LEVEL_3 = F.LEVEL_2 | F.ERROR;

  F.LEVEL_4 = F.LEVEL_3 | F.RES | F.ARGS;

  sflags = {
    m: F.METHOD,
    a: F.REMOTE,
    s: F.SEQID,
    t: F.TIMESTAMP,
    e: F.ERROR,
    p: F.ARG,
    r: F.REPLY,
    c: F.CLASS,
    d: F.DIRECTION,
    v: F.VERBOSE,
    A: F.ALL,
    0: F.LEVEL_0,
    1: F.LEVEL_1,
    2: F.LEVEL_2,
    3: F.LEVEL_3,
    4: F.LEVEL_4
  };

  dir = {
    INCOMING: 1,
    OUTGOING: 2
  };

  type = {
    SERVER: 1,
    CLIENT_NOTIFY: 2,
    CLIENT_CALL: 3
  };

  F2S = {};

  F2S[F.DIR] = {};

  F2S[F.DIR][dir.INCOMING] = "in";

  F2S[F.DIR][dir.OUTGOING] = "out";

  F2S[F.CLASS] = {};

  F2S[F.CLASS][type.SERVER] = "server";

  F2S[F.CLASS][type.CLIENT_NOTIFY] = "cli.notify";

  F2S[F.CLASS][type.CLIENT_CALL] = "cli.call";

  exports.constants = {
    type: type,
    dir: dir,
    flags: F,
    sflags: sflags,
    field_to_string: F2S
  };

  exports.sflags_to_flags = sflags_to_flags = function(s) {
    var c, i, res, _i, _ref;
    res = 0;
    for (i = _i = 0, _ref = s.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      c = s.charAt(i);
      res |= sflags[c];
    }
    return res;
  };

  exports.make_hook = function(flgs, fn) {
    sflags = flgs;
    if (typeof flgs === 'string') sflags = sflags_to_flags(flgs);
    return function(msg) {
      var V, do_copy, f2s, flag, key, new_msg, uck, val;
      new_msg = {};
      if (sflags & F.TIMESTAMP) {
        new_msg.timestamp = (new Date()).getTime() / 1000.0;
      }
      for (key in msg) {
        val = msg[key];
        uck = key.toUpperCase();
        flag = F[uck];
        V = sflags & F.VERBOSE;
        do_copy = (sflags & flag) === 0 ? false : key === "res" ? msg.dir === dir.OUTGOING || V : key === "arg" ? msg.dir === dir.INCOMING || V : true;
        if (do_copy) {
          f2s = F2S[flag];
          if ((f2s = F2S[flag]) != null) val = f2s(val);
          new_msg[key] = val;
        }
      }
      return fn(new_msg);
    };
  };

  exports.Message = Message = (function() {
    "A debug message --- a wrapper around a dictionary object, with\na few additional methods.";

    function Message(msg, hook) {
      this.msg = msg;
      this.hook = hook != null ? hook : null;
    }

    Message.prototype.response = function(error, result) {
      this.msg.error = error;
      this.msg.result = result;
      return this.msg.dir = dir.OUTGOING ? dir.INCOMING : dir.OUTGOING;
    };

    Message.prototype.msg = function() {
      return this.msg;
    };

    Message.prototype.call = function() {
      return this.hook(this.msg());
    };

    Message.prototype.set = function(k, v) {
      return this.msg[k] = v;
    };

    return Message;

  })();

}).call(this);
