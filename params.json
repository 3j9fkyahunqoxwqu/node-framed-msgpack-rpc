{"google":"","name":"Node-framed-msgpack-rpc","body":"Framed Msgpack RPC is an RPC system for node.js.  It allows\r\nclients to call remote procedures on servers.  An RPC consists of: (1)\r\na string name; (2) an argument that is a single JSON object;\r\n(3) a reply that is also a single JSON object.  Of course, those\r\nobjects can be arrays, or dictionaries, so arguments and return values\r\ncan be complex and interesting.\r\n\r\nThis system is a variant of the\r\n[Msgpack-RPC](http://redmine.msgpack.org/projects/msgpack/wiki/RPCDesign)\r\nprotocol specification for node.js.  Msgpack-RPC communicates\r\nbinary JSON objects that are efficiently encoded and decoded with the\r\n[MessagePack](http://msgpack.org) serialization format. \r\n\r\n\"Framed\" Msgpack-RPC differs from standard Msgpack-RPC in a small way:\r\nthe encoding of the length of the packet is prepended to each\r\npacket. This way, receivers can efficiently buffer data until a full\r\npacket is available to decode. In an event-based context like node.js,\r\nframing simplifies implementation, and yields a faster decoder,\r\nespecially for very large messages.\r\n\r\nBy convention, RPCs are grouped into _programs_, which can have\r\none or more _versions_.  Each (prog,vers) pair then has a collection\r\nof procedures, meaning an RPC is identified unabmiguously by a \r\n(prog,vers,proc) triple.  In practice, these three strings are\r\njoined with \".\" characters, and the dotted triple is the RPC name.\r\n\r\nDue to framing, this protocol is not compatible with existing\r\nMsgpack-RPC systems.  Support for Unix-Domain sockets is to come,\r\nbut there are no plans for UDP support.\r\n\r\n## Simple Use\r\n\r\nThe simplest way to write a server is with the `Server`\r\nclass as below:\r\n\r\n```javascript\r\nvar rpc = require('framed-msgpack-rpc');\r\nvar srv= new rpc.Server ({\r\n    programs : {\r\n        \"myprog.1\" : {\r\n            add : function(arg, response) {\r\n                response.result(arg.a + arg.b);\r\n            }\r\n        }\r\n    },\r\n    port : 8000 \r\n});\r\nsrv.listen(function (err) {\r\n    if (err) {\r\n        console.log(\"Error binding: \" + err);\r\n    } else {\r\n        console.log(\"Listening!\");\r\n    }\r\n});\r\n```\r\n\r\na corresponding client might look like:\r\n\r\n```javascript\r\nvar x = rpc.createTransport({ host: '127.0.0.1', port : 8000 });\r\nx.connect(function (err) {\r\n    if (err) {\r\n        console.log(\"error connecting\");\r\n    } else {\r\n        var c = new rpc.Client(x, \"myprog.1\");\r\n        c.invoke('add', { a : 5, b : 4}, function(err, response) {\r\n            if (err) {\r\n                console.log(\"error in RPC: \" + err);\r\n            } else { \r\n                assert.equal(9, response);\r\n            }\r\n            x.close();\r\n        });\r\n    }\r\n});\r\n```\r\n\r\nOr, equivalently, in beautiful \r\n[IcedCoffeeScript](https://github.com/maxtaco/coffee-script):\r\n\r\n```coffee\r\nx = rpc.createTransport { host: '127.0.0.1', port : 8000 }\r\nawait x.connect defer err\r\nif err?\r\n    console.log \"error connecting\"\r\nelse\r\n    c = new rpc.Client x, \"myprog.1\"\r\n    await c.invoke 'add', { a : 5, b : 4}, defer err, response\r\n    if err? then console.log \"error in RPC: #{err}\"\r\n    else assert.equal 9, response\r\n    x.close()\r\n```\r\n\r\n## Installation\r\n\r\nIt should work to just install with npm:\r\n   \r\n    npm install -g framed-msgpack-rpc\r\n\r\nIf you install by hand, you will need to install the one dependency,\r\nwhich is the [Msgpack C bindings](http://github.com/JulesAU/node-msgpack),\r\navailable as `msgpack2` on npm:\r\n\r\n    npm install -g msgpack2\r\n\r\n## Read On!\r\n\r\nFor full API documentation, see the GitHub-hosted [README](https://github.com/maxtaco/node-framed-msgpack-rpc) file.\r\n\r\n","tagline":"Fast and powerful RPC for Node","note":"Don't delete this file! It's used internally to help with page regeneration."}